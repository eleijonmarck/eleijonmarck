import { h as createVNode, F as Fragment } from './astro.98e1a385.mjs';
import 'html-escaper';
import 'cookie';
import 'kleur/colors';
import 'slash';
import 'path-to-regexp';
import 'mime';
import 'string-width';

const html = "<h2 id=\"merkle-trees\">Merkle trees</h2>\n<p>A merkel tree is a tree implementation in which every “leaf” node (leaf node is the single node at the bottom without children) is labelled with hash of a data block. Each non-leaf has the labelled hash of it’s children’s hash.\nThe benefits of a merkle tree or a hash tree is that it allows for efficient and secure verification of the contents of a large data structure.</p>\n<h3 id=\"why\">why</h3>\n<ul>\n<li>The Merkle tree is useful because it allows users to verify a specific transaction without downloading the whole blockchain (over 350 gigabytes for bitcoin for example).</li>\n</ul>\n<p>Hash trees can be used to verify the contents or data of a transferred between computers. They can also be used to help verify undamaged, unaltered datablocks in a peer-to-peer network. They are used in products like [[ipfs]] , [[git]] , [[bittorrent]], [[bitcoin]], [[ethereum]], nix package manager (Except that in the Nix object store, objects are not named by the SHA hash of their contents, but rather SHA hash of their build rules + their direct dependencies.).</p>\n<p>Demonstrating that a leaf node is part of a given binary hash tree requires computing of the log of the tree size. This makes merkle trees useful for a cryptographic application of commmitment verification schemes. Which the root of the tree is the commitment and the leaf node is the message.</p>\n<h3 id=\"nounce\">nounce</h3>\n<h3 id=\"how-does-a-new-leaf-node-get-added-to-the-tree\">how does a new leaf node get added to the tree</h3>\n<p>A new “commitment” to the scheme is created by hashing the message with a random value called a “nonce”. The nonce is then used to create a new commitment to the scheme. The new commitment is then hashed with the nonce to create a new commitment to the scheme. This process is repeated until the desired number of commitments is reached. The final commitment is then used to verify the message.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #81A1C1\">graph</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">BT</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">root</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">\"H_abcde\"</span><span style=\"color: #81A1C1\">] --></span><span style=\"color: #A3BE8C\"> </span><span style=\"color: #D8DEE9FF\">n1</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">\"H_2\"</span><span style=\"color: #81A1C1\">]</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">root</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">\"H_1\"</span><span style=\"color: #81A1C1\">] --></span><span style=\"color: #A3BE8C\"> </span><span style=\"color: #D8DEE9FF\">n2</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">\"H_2\"</span><span style=\"color: #81A1C1\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">ta</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">T_a</span><span style=\"color: #81A1C1\">] ---</span><span style=\"color: #A3BE8C\"> </span><span style=\"color: #D8DEE9FF\">ha</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">H_a</span><span style=\"color: #81A1C1\">]</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">tb</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">T_b</span><span style=\"color: #81A1C1\">] ---</span><span style=\"color: #A3BE8C\"> </span><span style=\"color: #D8DEE9FF\">hb</span><span style=\"color: #81A1C1\">[</span><span style=\"color: #A3BE8C\">H_b</span><span style=\"color: #81A1C1\">]</span></span></code></pre>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">graph</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">BT</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node</span><span style=\"color: #81A1C1\">(</span><span style=\"color: #A3BE8C\">\"top hash &#x3C;br> hash(node0 + node1)\"</span><span style=\"color: #81A1C1\">)</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node0</span><span style=\"color: #81A1C1\">(</span><span style=\"color: #A3BE8C\">\"node0 &#x3C;br> hash(node2 + node3)\"</span><span style=\"color: #81A1C1\">)</span><span style=\"color: #D8DEE9FF\"> --> node</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node1 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node2 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node0</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node3 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node0</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">node4 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node1</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">data0 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node2</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">data1 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node3</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">data2 </span><span style=\"color: #81A1C1\">--></span><span style=\"color: #D8DEE9FF\"> node4</span></span></code></pre>";

				const frontmatter = {"title":"Data structures: Merkle Trees","date":"2022-06-02","template":"post","draft":false,"slug":"merkle-trees","category":"software-engineering","tags":["software-engineering","data-structures"],"description":"Why merkle trees are becoming a everyday data structure that most engineers should know","socialImage":""};
				const file = "/Users/eleijonmarck/dev/eleijonmarck/better-bar/src/data/blog-posts/2022-06-02---merkletree.md";
				const url = undefined;
				function rawContent() {
					return "## Merkle trees\n\nA merkel tree is a tree implementation in which every \"leaf\" node (leaf node is the single node at the bottom without children) is labelled with hash of a data block. Each non-leaf has the labelled hash of it's children's hash.\nThe benefits of a merkle tree or a hash tree is that it allows for efficient and secure verification of the contents of a large data structure.\n\n### why\n- The Merkle tree is useful because it allows users to verify a specific transaction without downloading the whole blockchain (over 350 gigabytes for bitcoin for example).\n\nHash trees can be used to verify the contents or data of a transferred between computers. They can also be used to help verify undamaged, unaltered datablocks in a peer-to-peer network. They are used in products like [[ipfs]] , [[git]] , [[bittorrent]], [[bitcoin]], [[ethereum]], nix package manager (Except that in the Nix object store, objects are not named by the SHA hash of their contents, but rather SHA hash of their build rules + their direct dependencies.).\n\nDemonstrating that a leaf node is part of a given binary hash tree requires computing of the log of the tree size. This makes merkle trees useful for a cryptographic application of commmitment verification schemes. Which the root of the tree is the commitment and the leaf node is the message.\n\n### nounce\n\n\n### how does a new leaf node get added to the tree\nA new \"commitment\" to the scheme is created by hashing the message with a random value called a \"nonce\". The nonce is then used to create a new commitment to the scheme. The new commitment is then hashed with the nonce to create a new commitment to the scheme. This process is repeated until the desired number of commitments is reached. The final commitment is then used to verify the message. \n\n```mermaid\ngraph BT\nroot[\"H_abcde\"] --> n1[\"H_2\"]\nroot[\"H_1\"] --> n2[\"H_2\"]\n\nta[T_a] --- ha[H_a]\ntb[T_b] --- hb[H_b]\n```\n\n```mermaid\n\ngraph BT\n\nnode(\"top hash <br> hash(node0 + node1)\")\nnode0(\"node0 <br> hash(node2 + node3)\") --> node\nnode1 --> node\nnode2 --> node0\nnode3 --> node0\nnode4 --> node1\ndata0 --> node2\ndata1 --> node3\ndata2 --> node4\n```\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"merkle-trees","text":"Merkle trees"},{"depth":3,"slug":"why","text":"why"},{"depth":3,"slug":"nounce","text":"nounce"},{"depth":3,"slug":"how-does-a-new-leaf-node-get-added-to-the-tree","text":"how does a new leaf node get added to the tree"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
