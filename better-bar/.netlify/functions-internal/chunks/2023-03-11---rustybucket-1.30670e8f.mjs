import { h as createVNode, F as Fragment } from './astro.98e1a385.mjs';
import 'html-escaper';
import 'cookie';
import 'kleur/colors';
import 'slash';
import 'path-to-regexp';
import 'mime';
import 'string-width';

const html = "<h1 id=\"building-rusty-bucket---part-1\">Building Rusty Bucket - Part 1</h1>\n<h3 id=\"table-of-contents\">Table of Contents</h3>\n<ul>\n<li>Introduction</li>\n<li>Goals</li>\n<li>Non-goals</li>\n<li>Implementation</li>\n<li>Benchmarking</li>\n<li>Continuous Integration</li>\n<li>The Well-Used Bucket (Story)</li>\n</ul>\n<p>In this series of blog posts, I’ll chronicle my journey building a <code>pandas</code>-inspired data analysis library in Rust called <code>rustybucket</code> with some name brainstorming power thanks to @functorism. Today, we’ll focus on the core <code>Series</code> data structure and benchmark its performance.</p>\n<p><a href=\"https://github.com/eleijonmarck/rustybucket\" target=\"_blank\" rel=\"nofollow\">https://github.com/eleijonmarck/rustybucket</a> - ⭐</p>\n<h2 id=\"introduction\">Introduction</h2>\n<p>I use <code>pandas</code> extensively in both my professional and personal data analysis work, and I wanted to learn more about Rust by implementing core pieces of <code>pandas</code>’ functionality. My goal for <code>rustybucket</code> is to have a solid subset of <code>pandas</code>’ API implemented in Rust, allowing for exploration of Rust’s performance characteristics and my own learnings along the way.</p>\n<p>For part 1, I’m focusing on implementing <code>rustybucket</code>’s <code>Series</code> - a homogenous array of data with an associated index - and benchmarking basic operations on the structure.</p>\n<h3 id=\"goals\">Goals</h3>\n<ul>\n<li>Learn more about Rust and its ecosystem</li>\n<li>Implement a <code>Series</code> struct with indexing/slicing</li>\n<li>Write benchmarks to measure performance of core <code>Series</code> operations</li>\n</ul>\n<h3 id=\"non-goals\">Non-goals</h3>\n<ul>\n<li>Full <code>pandas</code> API coverage (for now)</li>\n<li>DataFrame or other higher-order structures</li>\n</ul>\n<h2 id=\"implementation\">Implementation</h2>\n<p>I started by setting up a new Rust library with <code>cargo new rustybucket --lib</code>. Since this is a library and not an executable, we don’t need a <code>main</code> function.</p>\n<p>For the <code>Series</code> implementation, I had to decide between using a <code>Vec</code> (owning, resizable array) or a <code>&#x26;[T]</code> slice (borrowed slice of elements). Since we may want to concatenate <code>Series</code> together or adjust capacity, <code>Vec</code> seemed like the clearer choice for now. Here’s the current <code>Series</code> struct:</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #81A1C1\">pub</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">struct</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Series</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">T</span><span style=\"color: #ECEFF4\">></span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #D8DEE9\">name</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">String</span><span style=\"color: #ECEFF4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #D8DEE9\">data</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Vec</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">T</span><span style=\"color: #ECEFF4\">>,</span></span>\n<span class=\"line\"><span style=\"color: #ECEFF4\">}</span></span></code></pre>\n<p>To enable indexing and slicing, I implemented <code>Index</code> and <code>Slice</code> traits for <code>Series</code>.</p>\n<p>With the core struct and traits in place, it was time to write some benchmarks! I used the <a href=\"https://crates.io/crates/criterion\" target=\"_blank\" rel=\"nofollow\"><code>criterion</code></a> crate to benchmark basic slicing operations on my <code>Series</code>.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #81A1C1\">use</span><span style=\"color: #D8DEE9FF\"> criterion</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #ECEFF4\">{</span><span style=\"color: #D8DEE9FF\">criterion_group</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> criterion_main</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Criterion</span><span style=\"color: #ECEFF4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">fn</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">slice_series</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #8FBCBB\">Series</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">i32</span><span style=\"color: #ECEFF4\">>,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">start</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">usize</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">end</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">usize</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #81A1C1\">let</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">_</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #D8DEE9\">start</span><span style=\"color: #81A1C1\">..</span><span style=\"color: #D8DEE9\">end</span><span style=\"color: #ECEFF4\">];</span></span>\n<span class=\"line\"><span style=\"color: #ECEFF4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">fn</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">criterion_benchmark</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">c</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;mut</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Criterion</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #81A1C1\">let</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Series</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #88C0D0\">new</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">String</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #88C0D0\">from</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #A3BE8C\">example</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #ECEFF4\">),</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #B48EAD\">0</span><span style=\"color: #81A1C1\">..</span><span style=\"color: #B48EAD\">1000</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">collect</span><span style=\"color: #ECEFF4\">());</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #D8DEE9\">c</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">bench_function</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #A3BE8C\">slice series</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">|</span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #81A1C1\">|</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">iter</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #81A1C1\">||</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">slice_series</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #B48EAD\">100</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #B48EAD\">200</span><span style=\"color: #ECEFF4\">)));</span></span>\n<span class=\"line\"><span style=\"color: #ECEFF4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #88C0D0; font-style: italic\">criterion_group!</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">benches</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">criterion_benchmark</span><span style=\"color: #ECEFF4\">);</span></span>\n<span class=\"line\"><span style=\"color: #88C0D0; font-style: italic\">criterion_main!</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">benches</span><span style=\"color: #ECEFF4\">);</span></span></code></pre>\n<p>It turns out that <code>criterion</code> cannot be used in conjunction with <code>benchmark-actions</code> and had to abandon the <code>criterion</code> library for doing the nightly builds with <code>#[bench]</code> instead.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #5E81AC\">#[bench]</span></span>\n<span class=\"line\"><span style=\"color: #81A1C1\">fn</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">slice_a_series_of_size_1000</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;mut</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">Bencher</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t</span><span style=\"color: #81A1C1\">fn</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">slice_series</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #81A1C1\">:</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #D8DEE9FF\">series</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #8FBCBB\">Series</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">i32</span><span style=\"color: #ECEFF4\">>)</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t</span><span style=\"color: #81A1C1\">let</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">_</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #B48EAD\">1</span><span style=\"color: #81A1C1\">..</span><span style=\"color: #B48EAD\">3</span><span style=\"color: #ECEFF4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t</span><span style=\"color: #ECEFF4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t</span><span style=\"color: #D8DEE9\">b</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">iter</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #81A1C1\">||</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t</span><span style=\"color: #81A1C1\">let</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">vec</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #B48EAD\">0</span><span style=\"color: #81A1C1\">..</span><span style=\"color: #B48EAD\">1000</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">map</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #81A1C1\">|</span><span style=\"color: #D8DEE9\">v</span><span style=\"color: #81A1C1\">|</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">v</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">+</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #B48EAD\">1000</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">collect</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">Vec</span><span style=\"color: #ECEFF4\">&#x3C;</span><span style=\"color: #8FBCBB\">i32</span><span style=\"color: #ECEFF4\">>>();</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t</span><span style=\"color: #81A1C1\">let</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> series</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #8FBCBB\">Series</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #88C0D0\">new</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">String</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #88C0D0\">from</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #A3BE8C\">hej</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #ECEFF4\">),</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">vec</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">None</span><span style=\"color: #ECEFF4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t</span><span style=\"color: #81A1C1\">for</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #D8DEE9\">_</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">in</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #B48EAD\">0</span><span style=\"color: #81A1C1\">..</span><span style=\"color: #B48EAD\">1000</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t\ttest</span><span style=\"color: #81A1C1\">::</span><span style=\"color: #88C0D0\">black_box</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #88C0D0\">slice_series</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #81A1C1\">&#x26;</span><span style=\"color: #D8DEE9\">s</span><span style=\"color: #ECEFF4\">));</span><span style=\"color: #616E88\"> // spooky black_box 👻</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t\t</span><span style=\"color: #ECEFF4\">}</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">\t</span><span style=\"color: #ECEFF4\">});</span></span>\n<span class=\"line\"><span style=\"color: #ECEFF4\">}</span></span></code></pre>\n<p>Just when I thought I had cleverly outwitted the Rust compiler’s optimizations by benchmarking my <code>slice_series</code> function. Rust discarded the redundant function calls, yielding a benchmark of <code>0 ns/iter</code> - infinite speed! ♾️</p>\n<p>Running this benchmark does however pose a problem as rust has optimization strategies for their compiler to disgard the function calls of slicing the series to only do it once. DAMN you rust toooo smooth. Instead one has to invoke a <code>black_box</code> call on top of the function being tested. The <code>test::black_box</code> function is an identity function that hints to the compiler to be maximally pessimistic about what <code>black_box</code> could do. All together we got out first benchmark test that actually did not have <code>0 ns/iter</code> but <code>412 ns/iter</code>, resulting in infinite performance regression 🤣.</p>\n<p><img src=\"/assets/blog/rust-infinite-perf-regression.png\" alt=\"benchmark\"></p>\n<p>I integrated benchmark testing into the continuous integration (CI) process for my project. This practice of including performance testing as part of CI is known as performance-driven development. Most programming languages and critical systems where performance is crucial (e.g. financial systems) implement this.</p>\n<p>This allows all team members to detect performance regressions that may arise from newly added features or bug fixes. We used the <code>benchmark-action</code> GitHub Action, which is specifically designed to run benchmarks in CI. After some trial and error, I got it working by setting up a <code>gh-pages</code> branch in the repository and adding a <code>dev/bench</code> folder on that branch.</p>\n<p><strong>Note:</strong> It was important to create the <code>gh-pages</code> branch and <code>dev/bench</code> directory because the <code>output.txt</code> file generated by <code>benchmark-action</code> expects those to exist in order to store the benchmark results. (I should have figured that out more quickly!)</p>\n<p>Finally, to track performance over time and detect regressions, I set up a GitHub Action to run <code>bench</code> benchmarks on every push and save the results. The <a href=\"https://github.com/marketplace/actions/github-action-for-benchmark\" target=\"_blank\" rel=\"nofollow\"><code>benchmark-action</code></a> made this process straightforward.</p>\n<p><img src=\"/assets/blog/rust-benchmark.png\" alt=\"benchmark\"></p>\n<p>You can see the current benchmark results for <code>rustybucket</code> in the <a href=\"https://eleijonmarck.github.io/rustybucket/dev/bench\" target=\"_blank\" rel=\"nofollow\">GitHub Pages site</a> for the project, or follow the development @ <a href=\"https://github.com/eleijonmarck/rustybucket\" target=\"_blank\" rel=\"nofollow\">https://github.com/eleijonmarck/rustybucket</a>.</p>\n<p>This is the end of part 1 where we make rustybucket the bucket for data that is rusty better.</p>\n<h4 id=\"the-well-used-bucket\">The Well-Used Bucket</h4>\n<p>I would like to share a tale about a bucket that served its purpose admirably, though not without signs of wear and tear.</p>\n<p>When it was first acquired, the bucket was gleaming and spotless. However, as time went on and the bucket was utilized repeatedly, it inevitably deteriorated. Its once-shiny exterior became weathered and discolored, coated in a layer of dirt and grime. Rust invaded the metal, leaving orange stains that could not be scrubbed away.</p>\n<p>If the bucket is not cleaned regularly, removing the built-up dust and debris and treating the rust before it spreads, it will soon become useless. What was once a perfectly suitable bucket will have transformed into a rusted relic, suitable only for the scrap heap.</p>";

				const frontmatter = {"title":"Building Rusty Bucket - Part 1","date":"2023-03-11","template":"post","draft":false,"slug":"rust: rusty bucket","category":"software-engineering","tags":["software-engineering","rust"],"description":"Rusty the bucket a performance benchmark for building pandas","socialImage":""};
				const file = "/Users/eleijonmarck/dev/eleijonmarck/better-bar/src/data/blog-posts/2023-03-11---rustybucket-1.md";
				const url = undefined;
				function rawContent() {
					return "\n# Building Rusty Bucket - Part 1\n\n### Table of Contents\n-   Introduction\n-   Goals\n-   Non-goals\n-   Implementation\n-   Benchmarking\n-   Continuous Integration\n-   The Well-Used Bucket (Story)\n\nIn this series of blog posts, I'll chronicle my journey building a `pandas`-inspired data analysis library in Rust called `rustybucket` with some name brainstorming power thanks to @functorism. Today, we'll focus on the core `Series` data structure and benchmark its performance.\n\nhttps://github.com/eleijonmarck/rustybucket - ⭐\n\n## Introduction\n\nI use `pandas` extensively in both my professional and personal data analysis work, and I wanted to learn more about Rust by implementing core pieces of `pandas`' functionality. My goal for `rustybucket` is to have a solid subset of `pandas`' API implemented in Rust, allowing for exploration of Rust's performance characteristics and my own learnings along the way.\n\nFor part 1, I'm focusing on implementing `rustybucket`'s `Series` - a homogenous array of data with an associated index - and benchmarking basic operations on the structure.\n\n### Goals\n\n-   Learn more about Rust and its ecosystem\n-   Implement a `Series` struct with indexing/slicing\n-   Write benchmarks to measure performance of core `Series` operations\n\n### Non-goals\n\n-   Full `pandas` API coverage (for now)\n-   DataFrame or other higher-order structures\n\n## Implementation\n\nI started by setting up a new Rust library with `cargo new rustybucket --lib`. Since this is a library and not an executable, we don't need a `main` function.\n\nFor the `Series` implementation, I had to decide between using a `Vec` (owning, resizable array) or a `&[T]` slice (borrowed slice of elements). Since we may want to concatenate `Series` together or adjust capacity, `Vec` seemed like the clearer choice for now. Here's the current `Series` struct:\n\n```rust\npub struct Series<T> {\n    name: String,\n    data: Vec<T>,\n}\n```\n\nTo enable indexing and slicing, I implemented `Index` and `Slice` traits for `Series`.\n\nWith the core struct and traits in place, it was time to write some benchmarks! I used the [`criterion`](https://crates.io/crates/criterion) crate to benchmark basic slicing operations on my `Series`.\n\n```rust\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nfn slice_series(s: &Series<i32>, start: usize, end: usize) {\n    let _ = &s[start..end];\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    let s = Series::new(String::from(\"example\"), (0..1000).collect());\n    c.bench_function(\"slice series\", |b| b.iter(|| slice_series(&s, 100, 200)));\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n```\n\nIt turns out that `criterion` cannot be used in conjunction with `benchmark-actions` and had to abandon the `criterion` library for doing the nightly builds with `#[bench]` instead.\n\n```rust\n#[bench]\nfn slice_a_series_of_size_1000(b: &mut Bencher) {\n\tfn slice_series(s: &series::Series<i32>) {\n\t\tlet _ = &s[1..3];\n\t}\n\n\tb.iter(|| {\n\t\tlet vec = (0..1000).map(|v| v + 1000).collect::<Vec<i32>>();\n\t\tlet s = series::Series::new(String::from(\"hej\"), vec, None);\n\t\tfor _ in 0..1000 {\n\t\t\ttest::black_box(slice_series(&s)); // spooky black_box 👻\n\t\t}\n\t});\n}\n```\n\nJust when I thought I had cleverly outwitted the Rust compiler's optimizations by benchmarking my `slice_series` function. Rust discarded the redundant function calls, yielding a benchmark of `0 ns/iter` - infinite speed! ♾️ \n\nRunning this benchmark does however pose a problem as rust has optimization strategies for their compiler to disgard the function calls of slicing the series to only do it once. DAMN you rust toooo smooth. Instead one has to invoke a `black_box` call on top of the function being tested. The `test::black_box` function is an identity function that hints to the compiler to be maximally pessimistic about what `black_box` could do. All together we got out first benchmark test that actually did not have `0 ns/iter` but `412 ns/iter`, resulting in infinite performance regression 🤣.\n\n![benchmark](/assets/blog/rust-infinite-perf-regression.png)\n\nI integrated benchmark testing into the continuous integration (CI) process for my project. This practice of including performance testing as part of CI is known as performance-driven development. Most programming languages and critical systems where performance is crucial (e.g. financial systems) implement this.\n\nThis allows all team members to detect performance regressions that may arise from newly added features or bug fixes. We used the `benchmark-action` GitHub Action, which is specifically designed to run benchmarks in CI. After some trial and error, I got it working by setting up a `gh-pages` branch in the repository and adding a `dev/bench` folder on that branch.\n\n**Note:** It was important to create the `gh-pages` branch and `dev/bench` directory because the `output.txt` file generated by `benchmark-action` expects those to exist in order to store the benchmark results. (I should have figured that out more quickly!)\n\nFinally, to track performance over time and detect regressions, I set up a GitHub Action to run `bench` benchmarks on every push and save the results. The [`benchmark-action`](https://github.com/marketplace/actions/github-action-for-benchmark) made this process straightforward.\n\n![benchmark](/assets/blog/rust-benchmark.png)\n\n\nYou can see the current benchmark results for `rustybucket` in the [GitHub Pages site](https://eleijonmarck.github.io/rustybucket/dev/bench) for the project, or follow the development @ https://github.com/eleijonmarck/rustybucket.\n\nThis is the end of part 1 where we make rustybucket the bucket for data that is rusty better.\n\n#### The Well-Used Bucket\nI would like to share a tale about a bucket that served its purpose admirably, though not without signs of wear and tear.\n\nWhen it was first acquired, the bucket was gleaming and spotless. However, as time went on and the bucket was utilized repeatedly, it inevitably deteriorated. Its once-shiny exterior became weathered and discolored, coated in a layer of dirt and grime. Rust invaded the metal, leaving orange stains that could not be scrubbed away.\n\nIf the bucket is not cleaned regularly, removing the built-up dust and debris and treating the rust before it spreads, it will soon become useless. What was once a perfectly suitable bucket will have transformed into a rusted relic, suitable only for the scrap heap.";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":1,"slug":"building-rusty-bucket---part-1","text":"Building Rusty Bucket - Part 1"},{"depth":3,"slug":"table-of-contents","text":"Table of Contents"},{"depth":2,"slug":"introduction","text":"Introduction"},{"depth":3,"slug":"goals","text":"Goals"},{"depth":3,"slug":"non-goals","text":"Non-goals"},{"depth":2,"slug":"implementation","text":"Implementation"},{"depth":4,"slug":"the-well-used-bucket","text":"The Well-Used Bucket"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
