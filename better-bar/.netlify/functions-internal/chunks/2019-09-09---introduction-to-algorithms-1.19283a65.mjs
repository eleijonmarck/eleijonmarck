import { h as createVNode, F as Fragment } from './astro.98e1a385.mjs';
import 'html-escaper';
import 'cookie';
import 'kleur/colors';
import 'slash';
import 'path-to-regexp';
import 'mime';
import 'string-width';

const html = "<p>This series will be covering the introduction of algorithms and their application.</p>\n<h3 id=\"why\">Why</h3>\n<ul>\n<li>Anywhere where realtime results want to be found quick. I want fassssst :)</li>\n<li>Efficiently calculating and handling the vast amount of data.</li>\n<li>Vast amount of twitter feed</li>\n<li>Sensor data</li>\n<li>Machine Learning model training</li>\n<li>Database queries</li>\n</ul>\n<p>If you are thinking that you are never gonna touch on these things. It might be true, but to have a basic understanding of algorithms will give much sense for dealing with for loops across anything you do.</p>\n<hr>\n<p>Algorithms can be traced back to the 9th century of a famous mathematician see <a href=\"http://cs-exhibitions.uni-klu.ac.at/index.php?id=193\" target=\"_blank\" rel=\"nofollow\">history of algorthms</a>. Nowadays everyone talks about algorithms, which is a fancy name of saying a set of intructions to follow. Given today, should not computational power overcome the means to calculate anything. Previously 1000 characters were seen as “big” data. If we had let’s say a string of 1 million characters; the computer today would be able to look through that in seconds. However what happens when we deal with all of the worlds roads or the blockchain of a specific cryptocurrency, suddenly efficiency becomes vital.</p>\n<blockquote>\n<p>Study of algorithms is a combination of size of input and efficiency.</p>\n</blockquote>\n<p>How does the algorithm actually evolve given more input, and we are talking about exponential time of execution or even worse given a specific chosen algorithm for a given problem.</p>\n<p>Algorithms can be categorised in these topics</p>\n<ul>\n<li>Graphs (which include Trees) - minimum number of moves for Rubik’s Cube</li>\n<li>Sorting - Event simulations</li>\n<li>Hashing - Genome sequencing</li>\n<li>Numerics - RSA, HTTPS</li>\n<li>Shortests Paths</li>\n<li>Dynamic Programming</li>\n</ul>\n<p>Here is an example on how to find the <em>peak</em> of a given array</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">array </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #B48EAD\">0</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">1</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">2</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">3</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">4</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">5</span><span style=\"color: #ECEFF4\">]</span></span></code></pre>\n<p>Let’s look at each element and see if that is bigger than the rest.</p>\n<p>We would call this the straightforward algorithm for this problem.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #81A1C1\">for</span><span style=\"color: #D8DEE9FF\"> i </span><span style=\"color: #81A1C1\">in</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #88C0D0\">range</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #88C0D0\">len</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">array</span><span style=\"color: #ECEFF4\">)):</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">    </span><span style=\"color: #81A1C1\">if</span><span style=\"color: #D8DEE9FF\"> array</span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #D8DEE9FF\">i</span><span style=\"color: #ECEFF4\">]</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #81A1C1\">></span><span style=\"color: #D8DEE9FF\"> max_value</span><span style=\"color: #ECEFF4\">:</span></span>\n<span class=\"line\"><span style=\"color: #D8DEE9FF\">        max_value </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> array</span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #D8DEE9FF\">i</span><span style=\"color: #ECEFF4\">]</span></span></code></pre>\n<p>We would therefore always have to look at all of the elements to find the peak.</p>\n<blockquote>\n<h3 id=\"time-complexity-is-on\">Time Complexity is <em>O(n)</em></h3>\n</blockquote>\n<hr>\n<blockquote>\n<h3 id=\"how-would-we-make-this-faster\">How would we make this faster?</h3>\n</blockquote>\n<p>Binary Search: A recursive algorithm <em>using</em> Divide and Conquer strategy</p>\n<p>Rewriting the array in elements of index 1 to n.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #D8DEE9FF\">array </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #ECEFF4\">[</span><span style=\"color: #B48EAD\">0</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #B48EAD\">1</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\">...n</span><span style=\"color: #81A1C1\">/</span><span style=\"color: #B48EAD\">2</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\">...</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\">n</span><span style=\"color: #81A1C1\">-</span><span style=\"color: #B48EAD\">1</span><span style=\"color: #ECEFF4\">,</span><span style=\"color: #D8DEE9FF\">n</span><span style=\"color: #ECEFF4\">]</span></span></code></pre>\n<ol start=\"0\">\n<li>Take element <code>n/2</code></li>\n<li>If <code>array[n/2] > array[n/2-1]</code>\n<ul>\n<li>look at left half <code>array[1,...,n/2 - 1]</code> for peak</li>\n</ul>\n</li>\n<li>Else if <code>array[n/2] &#x3C; array[n/2-1]</code>\n<ul>\n<li>look at right half <code>array[n/2,...,n]</code> for peak</li>\n</ul>\n</li>\n<li>Else <code>array[n/2]</code> is peak</li>\n</ol>\n<p>Given that we now “split” the input size in half each time we run the algorithm we get a time complexity of log n.</p>\n<pre is:raw=\"\" class=\"astro-code\" style=\"background-color: #2e3440ff; overflow-x: auto;\"><code><span class=\"line\"><span style=\"color: #d8dee9ff\">T(n) = T(n/2) + O(1)</span></span>\n<span class=\"line\"><span style=\"color: #d8dee9ff\">...</span></span>\n<span class=\"line\"><span style=\"color: #d8dee9ff\">T(n) = O(log n)</span></span></code></pre>\n<blockquote>\n<h3 id=\"time-complexity-is-olog-n\">Time Complexity is <em>O(log n)</em></h3>\n</blockquote>\n<p>This is EXPONENTIALLY faster.</p>\n<p>Just to give you a sense of what this intails:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th></th><th>input</th><th>time</th><th></th><th></th></tr></thead><tbody><tr><td>O(n)</td><td>10^5</td><td>13 seconds</td><td></td><td></td></tr><tr><td>O(logn)</td><td>10^5</td><td>0.0001 seconds</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>";

				const frontmatter = {"title":"Introduction to Algorithms","date":"2019-09-09T22:40:32.169Z","template":"post","draft":false,"slug":"introduction-to-algorithms-1","category":"algorithms","tags":["data-structures","algorithms"],"description":"Short introduction to why to learn algorithms","socialImage":""};
				const file = "/Users/eleijonmarck/dev/eleijonmarck/better-bar/src/data/blog-posts/2019-09-09---introduction-to-algorithms-1.md";
				const url = undefined;
				function rawContent() {
					return "\nThis series will be covering the introduction of algorithms and their application.\n\n### Why\n- Anywhere where realtime results want to be found quick. I want fassssst :)\n- Efficiently calculating and handling the vast amount of data.\n - Vast amount of twitter feed\n - Sensor data\n - Machine Learning model training\n - Database queries\n\nIf you are thinking that you are never gonna touch on these things. It might be true, but to have a basic understanding of algorithms will give much sense for dealing with for loops across anything you do.\n\n---\nAlgorithms can be traced back to the 9th century of a famous mathematician see [history of algorthms](http://cs-exhibitions.uni-klu.ac.at/index.php?id=193). Nowadays everyone talks about algorithms, which is a fancy name of saying a set of intructions to follow. Given today, should not computational power overcome the means to calculate anything. Previously 1000 characters were seen as \"big\" data. If we had let's say a string of 1 million characters; the computer today would be able to look through that in seconds. However what happens when we deal with all of the worlds roads or the blockchain of a specific cryptocurrency, suddenly efficiency becomes vital.\n> Study of algorithms is a combination of size of input and efficiency.\n\nHow does the algorithm actually evolve given more input, and we are talking about exponential time of execution or even worse given a specific chosen algorithm for a given problem.\n\nAlgorithms can be categorised in these topics\n* Graphs (which include Trees) - minimum number of moves for Rubik's Cube\n* Sorting - Event simulations\n* Hashing - Genome sequencing\n* Numerics - RSA, HTTPS\n* Shortests Paths\n* Dynamic Programming\n\n\nHere is an example on how to find the *peak* of a given array\n\n\n```python\narray = [0,1,2,3,4,5]\n```\n\nLet's look at each element and see if that is bigger than the rest.\n\nWe would call this the straightforward algorithm for this problem.\n\n```python\nfor i in range(len(array)):\n    if array[i] > max_value:\n        max_value = array[i]\n```\n\nWe would therefore always have to look at all of the elements to find the peak.\n\n> ### Time Complexity is *O(n)*\n\n---\n> ###  How would we make this faster?\n\nBinary Search: A recursive algorithm *using* Divide and Conquer strategy\n\nRewriting the array in elements of index 1 to n.\n```python\narray = [0,1,...n/2,...,n-1,n]\n```\n0. Take element `n/2`\n1. If `array[n/2] > array[n/2-1]`\n   - look at left half `array[1,...,n/2 - 1]` for peak\n2. Else if `array[n/2] < array[n/2-1]`\n    - look at right half `array[n/2,...,n]` for peak\n3. Else `array[n/2]` is peak\n\n\nGiven that we now \"split\" the input size in half each time we run the algorithm we get a time complexity of log n.\n```\nT(n) = T(n/2) + O(1)\n...\nT(n) = O(log n)\n```\n\n> ### Time Complexity is *O(log n)*\n\nThis is EXPONENTIALLY faster.\n\nJust to give you a sense of what this intails:\n\n|          | input | time           |   |   |\n|----------|-------|----------------|---|---|\n| O(n)     | 10^5  | 13 seconds     |   |   |\n| O(logn) | 10^5  | 0.0001 seconds |   |   |\n|          |       |                |   |   |\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":3,"slug":"why","text":"Why"},{"depth":3,"slug":"time-complexity-is-on","text":"Time Complexity is O(n)"},{"depth":3,"slug":"how-would-we-make-this-faster","text":"How would we make this faster?"},{"depth":3,"slug":"time-complexity-is-olog-n","text":"Time Complexity is O(log n)"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
